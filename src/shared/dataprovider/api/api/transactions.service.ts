/**
 * DynastyGateway API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs';

import { ProblemDetails } from '../model/problemDetails';
import { UserCashInDTO } from '../model/userCashInDTO';
import { UserCreateCashInRequestDTO } from '../model/userCreateCashInRequestDTO';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { environment } from 'src/environments/environment';
import { CreateCashoutDto } from '../model/createCashoutDto';
import { UserCashOutDTO } from '../model/userCashOutDTO';
import { UserTopUpDTO } from '../model/userTopUpDTO';
import { UserUpdateTopUpRequestDTO } from '../model/userUpdateTopUpRequestDTO';
import { UserBalanceTransferDTO } from '../model/userBalanceTransferDTO';
import { TopUpStatusEnum } from '../model/topUpStatusEnum';
import { UserCreateBalanceTransferRequestDTO } from '../model/userCreateBalanceTransferRequestDTO';
import { UserUpdateBalanceTransferRequestDTO } from '../model/userUpdateBalanceTransferRequestDTO';
import { BalanceTransferDataDTO } from '../model/balanceTransferDataDTO';
import { GetListBalanceTransferRequestDTO } from '../model/getListBalanceTransferRequestDTO';
import { ResendWebhookRequestDTO } from '../model/resendWebhookRequestDTO';
import { CashoutDigipayWebhookRequestDTO } from '../model/cashoutDigipayWebhookRequestDTO';
import { CashoutWebhookResponse } from '../model/cashoutWebhookResponse';
import { DigipayManualCallbackDTO } from '../model/digipayManualCallbackDTO';
import { BalanceTransferRequestDTO } from '../model/balanceTransferRequestDTO';
import { UpdateBalanceTransferRequestDTO } from '../model/updateBalanceTransferRequestDTO';
import { BalanceTransferFundsListDTO } from '../model/balanceTransferFundsListDTO';


@Injectable()
export class TransactionsService {

    protected basePath = environment.basePath;
    public token = sessionStorage.getItem("token") || '';
    public defaultHeaders = new HttpHeaders({
        'X-API-KEY': environment.APIkey,
        'Authorization': this.token ? `Bearer ${this.token}` : '',
    });
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
      * Creates a balance transfer request to fund the CO balance.
      * 
      * @param body The request body contains the following:
  1. ClientId - Client&#x27;s Id
  2. SourceMerchantId - Merchant Id that will be the source of Funds 
  3. Amount - Gross Amount to be transferred      
  4. Remarks - any remarks made on the top up transaction
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
    public apiTransactionsBalanceTransferRequestFundForCOPost(body?: UserCreateBalanceTransferRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<UserBalanceTransferDTO>;
    public apiTransactionsBalanceTransferRequestFundForCOPost(body?: UserCreateBalanceTransferRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserBalanceTransferDTO>>;
    public apiTransactionsBalanceTransferRequestFundForCOPost(body?: UserCreateBalanceTransferRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserBalanceTransferDTO>>;
    public apiTransactionsBalanceTransferRequestFundForCOPost(body?: UserCreateBalanceTransferRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserBalanceTransferDTO>('post', `${this.basePath}/api/Transactions/BalanceTransfer/RequestFundForCO`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
       * Updates a balance transfer request to fund the CO balance.
       * 
       * @param body The request body contains the following:
   1. TransactionNumber - Transaction Number of the request
   2. Status - New Status of the transaction (2 - Approved, 3 - Rejected)
       * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
       * @param reportProgress flag to report request and response progress.
       */
    public apiTransactionsBalanceTransferRequestFundForCOPut(body?: UserUpdateBalanceTransferRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<UserBalanceTransferDTO>;
    public apiTransactionsBalanceTransferRequestFundForCOPut(body?: UserUpdateBalanceTransferRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserBalanceTransferDTO>>;
    public apiTransactionsBalanceTransferRequestFundForCOPut(body?: UserUpdateBalanceTransferRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserBalanceTransferDTO>>;
    public apiTransactionsBalanceTransferRequestFundForCOPut(body?: UserUpdateBalanceTransferRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserBalanceTransferDTO>('put', `${this.basePath}/api/Transactions/BalanceTransfer/RequestFundForCO`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Creates a manual top up for a specific merchant of the client.
    * 
    * @param clientId 
    * @param amount 
    * @param modeOfPayment 
    * @param referenceNumber 
    * @param depositSlips 
    * @param dateOfDeposit 
    * @param remarks 
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public apiTransactionsCashinsManualTopUpPostForm(clientId?: number, amount?: number, modeOfPayment?: string, referenceNumber?: string, depositSlips?: Array<Blob>, dateOfDeposit?: Date, remarks?: string, observe?: 'body', reportProgress?: boolean): Observable<UserTopUpDTO>;
    public apiTransactionsCashinsManualTopUpPostForm(clientId?: number, amount?: number, modeOfPayment?: string, referenceNumber?: string, depositSlips?: Array<Blob>, dateOfDeposit?: Date, remarks?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserTopUpDTO>>;
    public apiTransactionsCashinsManualTopUpPostForm(clientId?: number, amount?: number, modeOfPayment?: string, referenceNumber?: string, depositSlips?: Array<Blob>, dateOfDeposit?: Date, remarks?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserTopUpDTO>>;
    public apiTransactionsCashinsManualTopUpPostForm(clientId?: number, amount?: number, modeOfPayment?: string, referenceNumber?: string, depositSlips?: Array<Blob>, dateOfDeposit?: Date, remarks?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        }

        if (clientId !== undefined) {
            formParams = formParams.append('ClientId', <any>clientId) as any || formParams;
        }
        if (amount !== undefined) {
            formParams = formParams.append('Amount', <any>amount) as any || formParams;
        }
        if (modeOfPayment !== undefined) {
            formParams = formParams.append('ModeOfPayment', <any>modeOfPayment) as any || formParams;
        }
        if (referenceNumber !== undefined) {
            formParams = formParams.append('ReferenceNumber', <any>referenceNumber) as any || formParams;
        }
        if (depositSlips) {
            depositSlips.forEach((element) => {
                formParams = formParams.append('DepositSlips', <any>element) as any || formParams;
            })
        }
        if (dateOfDeposit !== undefined) {
            formParams = formParams.append('DateOfDeposit', <any>dateOfDeposit) as any || formParams;
        }
        if (remarks !== undefined) {
            formParams = formParams.append('Remarks', <any>remarks) as any || formParams;
        }

        return this.httpClient.request<UserTopUpDTO>('post', `${this.basePath}/api/Transactions/Cashins/ManualTopUp`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Updates a manual top up for a specific merchant of the client.
     * 
     * @param body The request body contains the following:
 1. TransactionNumber - transaction number of top up.
 2. Status - New status of the transaction
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCashinsManualTopUpPut(body?: UserUpdateTopUpRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<UserTopUpDTO>;
    public apiTransactionsCashinsManualTopUpPut(body?: UserUpdateTopUpRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserTopUpDTO>>;
    public apiTransactionsCashinsManualTopUpPut(body?: UserUpdateTopUpRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserTopUpDTO>>;
    public apiTransactionsCashinsManualTopUpPut(body?: UserUpdateTopUpRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserTopUpDTO>('put', `${this.basePath}/api/Transactions/Cashins/ManualTopUp`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This is to check the transaction status of a cash in transaction.
     * 
     * @param transactionNumber This is the transaction number generated from the CreateCashIn api.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCashinsQueryGet(transactionNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<UserCashInDTO>;
    public apiTransactionsCashinsQueryGet(transactionNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserCashInDTO>>;
    public apiTransactionsCashinsQueryGet(transactionNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserCashInDTO>>;
    public apiTransactionsCashinsQueryGet(transactionNumber?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (transactionNumber !== undefined && transactionNumber !== null) {
            queryParameters = queryParameters.set('transactionNumber', <any>transactionNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserCashInDTO>('get', `${this.basePath}/api/Transactions/Cashins/Query`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This is to check the transaction status of a cash out transaction.
     * 
     * @param transactionNumber Search by TransactionNumber, OrderNumber or ReferenceUserId generated from the CreateCashOut api.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCashoutsQueryGet(transactionNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<UserCashOutDTO>;
    public apiTransactionsCashoutsQueryGet(transactionNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserCashOutDTO>>;
    public apiTransactionsCashoutsQueryGet(transactionNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserCashOutDTO>>;
    public apiTransactionsCashoutsQueryGet(transactionNumber?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (transactionNumber !== undefined && transactionNumber !== null) {
            queryParameters = queryParameters.set('transactionNumber', <any>transactionNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserCashOutDTO>('get', `${this.basePath}/api/Transactions/Cashouts/Query`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new cash in request for a user.
     * 
     * @param body The request body containts the following:
 1. MerchantId - Merchant Id assigned to client to be used for cash in, calculation of fees will be based on the merchant id used. There can be multiple merchant IDs in the future depending on its availability.
 2. Amount - Gross Amount to be cashed in
 3. ReferenceUserId - The client&#x27;s player identification
 4. NotificationUrl -  This url will be the location where the actual payment response will be 
 5. SuccessRedirectUrl - This url will be the location where the customer will be returned after the transaction is successful
 6. CancelRedirectUrl - This url will be the location the customer will be returned if the customer pressed the cancel button
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCreateCashInPost(body?: UserCreateCashInRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<UserCashInDTO>;
    public apiTransactionsCreateCashInPost(body?: UserCreateCashInRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserCashInDTO>>;
    public apiTransactionsCreateCashInPost(body?: UserCreateCashInRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserCashInDTO>>;
    public apiTransactionsCreateCashInPost(body?: UserCreateCashInRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserCashInDTO>('post', `${this.basePath}/api/Transactions/CreateCashIn`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new cash out request for all merchants.
     * &lt;br&gt;               This API endpoint allows you to create a new cash out request for a user.                 &lt;br&gt;               The request parameter contains the data required to create the cash out request.               
     * @param body The request data for creating the cash out.
1. MerchantId - Merchant Id assigned to client to be used for cash out, calculation of fees will be based on the merchant id used. There can be multiple merchant IDs in the future depending on its availability.
2. Amount - Amount to be cashed out
3. ReferenceUserId - The client&#x27;s player identification
4. AccountNumber - Receiver’s bank account number
5. HolderName - Receiver’s full name
6. Bank - Name of the bank.
7. BankCode - Code name of the bank.
8. BankAccountType - Account type. Options: (PERSONAL,CORPORATE, GOVERNMENT)
9. ReceipientMobileNumber - The mobile number of the recipient of the cash out.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCreateCashOutPost(body?: CreateCashoutDto, observe?: 'body', reportProgress?: boolean): Observable<UserCashOutDTO>;
    public apiTransactionsCreateCashOutPost(body?: CreateCashoutDto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserCashOutDTO>>;
    public apiTransactionsCreateCashOutPost(body?: CreateCashoutDto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserCashOutDTO>>;
    public apiTransactionsCreateCashOutPost(body?: CreateCashoutDto, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserCashOutDTO>('post', `${this.basePath}/api/Transactions/CreateCashOut`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Handles notifications from partner vendors.
     * 
     * @param body response from vendor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsNotifyPost(body?: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public apiTransactionsNotifyPost(body?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public apiTransactionsNotifyPost(body?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiTransactionsNotifyPost(body?: any, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<string>('post', `${this.basePath}/api/Transactions/Notify`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
 * Retrieves the list of balance transfer requests to fund the CO balance.   The transactions are generated from Client Channel Wallet balance into Remittance Wallet balance.
 * 
 * @param body The request body contains the following:
1. ClientId - Client&#x27;s Id
2. StartDate - start date of transaction filter
2. EndDate - end date of transaction filter
 * @param pageSize 
 * @param pageNumber 
 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
 * @param reportProgress flag to report request and response progress.
 */
    public apiTransactionsBalanceTransferRequestFundForCOListPost(body?: GetListBalanceTransferRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<BalanceTransferDataDTO>>;
    public apiTransactionsBalanceTransferRequestFundForCOListPost(body?: GetListBalanceTransferRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BalanceTransferDataDTO>>>;
    public apiTransactionsBalanceTransferRequestFundForCOListPost(body?: GetListBalanceTransferRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BalanceTransferDataDTO>>>;
    public apiTransactionsBalanceTransferRequestFundForCOListPost(body?: GetListBalanceTransferRequestDTO, pageSize?: number, pageNumber?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {




        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Array<BalanceTransferDataDTO>>('post', `${this.basePath}/api/Transactions/BalanceTransfer/RequestFundForCOList`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the deposit slip images formatted in html.
     * 
     * @param transactionNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiTransactionsCashinsManualTopUpDepositSlipGet(transactionNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiTransactionsCashinsManualTopUpDepositSlipGet(transactionNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiTransactionsCashinsManualTopUpDepositSlipGet(transactionNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiTransactionsCashinsManualTopUpDepositSlipGet(transactionNumber?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (transactionNumber !== undefined && transactionNumber !== null) {
            queryParameters = queryParameters.set('transactionNumber', <any>transactionNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get', `${this.basePath}/api/Transactions/Cashins/ManualTopUp/DepositSlip/ImagesURLs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This is to check the transaction status of a cash in transaction. Resend the the result of transaction back to the registered webhook of transaction.
     * 
     * @param body This contains the list of transaction numbers generated from the CreateCashIn api.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resendWebHook(body?: ResendWebhookRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public resendWebHook(body?: ResendWebhookRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public resendWebHook(body?: ResendWebhookRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public resendWebHook(body?: ResendWebhookRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<boolean>('post', `${this.basePath}/api/Transactions/Cashins/Query/ResendWebhook`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
  * Resend cashout webhook to client
  * 
  * @param transactionNumber 
  * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
  * @param reportProgress flag to report request and response progress.
  */
    public CashoutSendCallbackToClient(transactionNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<DigipayManualCallbackDTO>;
    public CashoutSendCallbackToClient(transactionNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DigipayManualCallbackDTO>>;
    public CashoutSendCallbackToClient(transactionNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DigipayManualCallbackDTO>>;
    public CashoutSendCallbackToClient(transactionNumber?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (transactionNumber !== undefined && transactionNumber !== null) {
            queryParameters = queryParameters.set('TransactionNumber', <any>transactionNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DigipayManualCallbackDTO>('put', `${this.basePath}/api/Transactions/Cashout/SendCallbackToClient`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
        * Creates a balance transfer request.
        * 
        * @param body The request body contains the following:   1. ClientId - Client&#x27;s Id   2. SourceChannelId - Source Payment Channel Id       [used in Wallet to Remittance Wallet, COF to Remittance Wallet, Wallet to COF]   3. DestinationChannelId &#x3D; Destination Channel Id      [used in COF to Wallet, Remittance Wallet to COF, Remittance Wallet to Wallet]   4. Amount - Gross Amount to be transferred   5. Remarks - any remarks made on the top up transaction   6. TransferType - [5 - Wallet to COF, 6 - Wallet to Remittance Wallet, 7 - COF to Wallet, 8 - COF to Remittance Wallet, 9 - Remittance Wallet to COF, 10 - Remittance Wallet to Wallet, 11 - Wallet to Wallet]
        * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
        * @param reportProgress flag to report request and response progress.
        */
    public createBalanceTransfer(body?: BalanceTransferRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<UserBalanceTransferDTO>;
    public createBalanceTransfer(body?: BalanceTransferRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserBalanceTransferDTO>>;
    public createBalanceTransfer(body?: BalanceTransferRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserBalanceTransferDTO>>;
    public createBalanceTransfer(body?: BalanceTransferRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UserBalanceTransferDTO>('post', `${this.basePath}/api/Transactions/BalanceTransfer`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a balance transfer request.
     * 
     * @param body The request body contains the following:   1. TransactionNumber - Transaction Number of the request   2. Status - New Status of the transaction (2 - Approved, 3 - Rejected)   3. List of Sources   4. List of Destinations   5. Remarks   6. TransferType - [5 - Wallet to COF, 6 - Wallet to Remittance Wallet, 7 - COF to Wallet, 8 - COF to Remittance Wallet, 9 - Remittance Wallet to COF, 10 - Remittance Wallet to Wallet, 11 - Wallet to Wallet]
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateBalanceTransfer(body?: UpdateBalanceTransferRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateBalanceTransfer(body?: UpdateBalanceTransferRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateBalanceTransfer(body?: UpdateBalanceTransferRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateBalanceTransfer(body?: UpdateBalanceTransferRequestDTO, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put', `${this.basePath}/api/Transactions/BalanceTransfer`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
* Retrieves list of balance transfer requests.
* 
* @param clientId Client&#x27;s Id
* @param startDate Date: Format (YYYY-MM-DD)
* @param endDate Date: Format (YYYY-MM-DD)
* @param pageSize Page Size
* @param pageNumber Page Number
* @param searchKeyword Serach Keyword
* @param status Status
* @param transferTypes TransferType - [5 - Wallet to COF, 6 - Wallet to Remittance Wallet, 7 - COF to Wallet, 8 - COF to Remittance Wallet, 9 - Remittance Wallet to COF, 10 - Remittance Wallet to Wallet, 11 - Wallet to Wallet]
* @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
* @param reportProgress flag to report request and response progress.
*/
    public getBalanceTransferTransactions(clientId?: number, startDate?: Date, endDate?: Date, pageSize?: number, pageNumber?: number, searchKeyword?: string, statuses?: string, transferTypes?: string, observe?: 'body', reportProgress?: boolean): Observable<BalanceTransferFundsListDTO>;
    public getBalanceTransferTransactions(clientId?: number, startDate?: Date, endDate?: Date, pageSize?: number, pageNumber?: number, searchKeyword?: string, statuses?: string, transferTypes?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BalanceTransferFundsListDTO>>;
    public getBalanceTransferTransactions(clientId?: number, startDate?: Date, endDate?: Date, pageSize?: number, pageNumber?: number, searchKeyword?: string, statuses?: string, transferTypes?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BalanceTransferFundsListDTO>>;
    public getBalanceTransferTransactions(clientId?: number, startDate?: Date, endDate?: Date, pageSize?: number, pageNumber?: number, searchKeyword?: string, statuses?: string, transferTypes?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (statuses !== undefined && statuses !== null) {
            queryParameters = queryParameters.set('statuses', <any>statuses);
        }
        if (transferTypes !== undefined && transferTypes !== null) {
            queryParameters = queryParameters.set('transferTypes', <any>transferTypes);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BalanceTransferFundsListDTO>('get', `${this.basePath}/api/Transactions/BalanceTransfer`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
}
