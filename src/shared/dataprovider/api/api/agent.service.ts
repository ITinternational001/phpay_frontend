/**
 * DynastyGateway API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AgentBrandsDTO } from '../model/agentBrandsDTO';
import { AgentDTOV2 } from '../model/agentDTOV2';
import { AgentListDTO } from '../model/agentListDTO';
import { AgentTypeEnum } from '../model/agentTypeEnum';
import { AgentUsernameDTO } from '../model/agentUsernameDTO';
import { AgentWithClientsDTO } from '../model/agentWithClientsDTO';
import { AssignBrandRequest } from '../model/assignBrandRequest';
import { BrandNameDTO } from '../model/brandNameDTO';
import { ClientAgentAllocationDTO } from '../model/clientAgentAllocationDTO';
import { ProblemDetails } from '../model/problemDetails';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { environment } from 'src/environments/environment';
import { AgentRequestForBalanceTransferDTO } from '../model/agentRequestForBalanceTransferDTO';
import { AgentClientChannelSummaryDTO } from '../model/agentClientChannelSummaryDTO';
import { DeclineResponseDTO } from '../model/declineResponseDTO';
import { AgentBalanceTransfer } from '../model/agentBalanceTransfer';
import { BalanceTransferListDTOV2 } from '../model/balanceTransferListDTOV2';
import { BalanceTransferListDTO } from '../model/balanceTransferListDTO';
import { ApproveRequestBalanceTransfer } from '../model/approveRequestBalanceTransfer';
import { ApproveResponseDTO } from '../model/approveResponseDTO';
import { AgentCardTransaction } from '../model/agentCardTransaction';
import { CardTransactionRequest } from '../model/cardTransactionRequest';
import { AgentCard } from '../model/agentCard';
import { AgentBankType } from '../model/agentBankType';
import { CardListDTO } from '../model/cardListDTO';
import { AgentTopCardDTO } from '../model/agentTopCardDTO';
import { AgentRemittanceListOfClientSummary } from '../model/agentRemittanceListOfClientSummary';
import { CardRequestDTO } from '../model/cardRequestDTO';
import { DashboardTotalCommDTO } from '../model/dashboardTotalCommDTO';
import { DateFilter } from '../model/dateFilter';
import { AgentReportTransactionLog } from '../model/agentReportTransactionLog';
import { ReportAccountFlowSummary } from '../model/reportAccountFlowSummary';
import { AgentChannelsDTO } from '../model/agentChannelsDTO';
import { AgentRemittanceListDTO } from '../model/agentRemittanceListDTO';
import { AgentRemittance } from '../model/agentRemittance';
import { AgentRemittanceListSummaryDTO } from '../model/agentRemittanceListSummaryDTO';
import { RemittnaceDeclineDTO } from '../model/remittnaceDeclineDTO';
import { AgentApprovedRemittanceRequest } from '../model/agentApprovedRemittanceRequest';
import { AgentCardRequestRemittance } from '../model/agentCardRequestRemittance';
import { AgentIdType } from '../model/agentIdType';


@Injectable()
export class AgentService {
    
    protected basePath = environment.basePath;
    public token = sessionStorage.getItem("token") || '';
    public defaultHeaders = new HttpHeaders({
        'X-API-KEY': environment.APIkey,
        'Authorization': this.token ? `Bearer ${this.token}` : '',
    });
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Enable/Disable Agent in Agent Allocation Screen
     * 
     * @param agentId Status change to 1-Active or 2-Inactive
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentAllocationEnableDisableAgentPut(agentId?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentDTOV2>;
    public apiAgentAllocationEnableDisableAgentPut(agentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentDTOV2>>;
    public apiAgentAllocationEnableDisableAgentPut(agentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentDTOV2>>;
    public apiAgentAllocationEnableDisableAgentPut(agentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentDTOV2>('put',`${this.basePath}/api/Agent/Allocation/EnableDisableAgent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the list of Clients and their corresponding Agents.
     * 
     * @param clientId CLient Id
     * @param clientName Client Name
     * @param agentName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentAllocationGetClientAgentListGet(clientId?: number, clientName?: string, agentName?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ClientAgentAllocationDTO>>;
    public apiAgentAllocationGetClientAgentListGet(clientId?: number, clientName?: string, agentName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ClientAgentAllocationDTO>>>;
    public apiAgentAllocationGetClientAgentListGet(clientId?: number, clientName?: string, agentName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ClientAgentAllocationDTO>>>;
    public apiAgentAllocationGetClientAgentListGet(clientId?: number, clientName?: string, agentName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (clientName !== undefined && clientName !== null) {
            queryParameters = queryParameters.set('clientName', <any>clientName);
        }
        if (agentName !== undefined && agentName !== null) {
            queryParameters = queryParameters.set('agentName', <any>agentName);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ClientAgentAllocationDTO>>('get',`${this.basePath}/api/Agent/Allocation/GetClientAgentList`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assign Client to an Agent
     * 
     * @param body 1. &quot;AgentId&quot; - The Agent Id where the Client will be assigned.
2. &quot;BrandId&quot;: - The Client Id to be assigned to an Agent.
3. &quot;Status&quot;: 1-Active, 2-Inactive
4. &quot;CiCommissionRate&quot; - Cashin Rate per client.
5. &quot;CoCommissionRate&quot; - Cashout Rate per client.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementAssignNewClientPut(body?: AssignBrandRequest, observe?: 'body', reportProgress?: boolean): Observable<AgentBrandsDTO>;
    public apiAgentManagementAssignNewClientPut(body?: AssignBrandRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentBrandsDTO>>;
    public apiAgentManagementAssignNewClientPut(body?: AssignBrandRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentBrandsDTO>>;
    public apiAgentManagementAssignNewClientPut(body?: AssignBrandRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<AgentBrandsDTO>('put',`${this.basePath}/api/Agent/Management/AssignNewClient`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves Agent Types for UI drop down (Add new agent)
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementGetAgentTypesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public apiAgentManagementGetAgentTypesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public apiAgentManagementGetAgentTypesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public apiAgentManagementGetAgentTypesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<any>>('get',`${this.basePath}/api/Agent/Management/GetAgentTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the list of Brands and their corresponding commissionRate.
     * 
     * @param agentId Agent&#x27;s Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementGetAgentWithClientsCommissionRateGet(agentId?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentWithClientsDTO>;
    public apiAgentManagementGetAgentWithClientsCommissionRateGet(agentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentWithClientsDTO>>;
    public apiAgentManagementGetAgentWithClientsCommissionRateGet(agentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentWithClientsDTO>>;
    public apiAgentManagementGetAgentWithClientsCommissionRateGet(agentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentWithClientsDTO>('get',`${this.basePath}/api/Agent/Management/GetAgentWithClientsCommissionRate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves list of Agent Id&#x27;s and Usernames for UI Dropdown(Add new agent &gt; Upline Agent)
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementGetAllAgentUserNamesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<AgentUsernameDTO>>;
    public apiAgentManagementGetAllAgentUserNamesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AgentUsernameDTO>>>;
    public apiAgentManagementGetAllAgentUserNamesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AgentUsernameDTO>>>;
    public apiAgentManagementGetAllAgentUserNamesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AgentUsernameDTO>>('get',`${this.basePath}/api/Agent/Management/GetAllAgentUserNames`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

  /**
     * Retrieves list of Brand names for UI Dropdown(Assign New Client)
     * 
     * @param agentId If agentId is null, will return Clients that are not yet assigned, otherwise will return Clients associated with the agentId
     * @param agentType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
  public apiAgentManagementGetAllBrandNamesGet(agentId?: number, agentType?: AgentTypeEnum, observe?: 'body', reportProgress?: boolean): Observable<Array<BrandNameDTO>>;
  public apiAgentManagementGetAllBrandNamesGet(agentId?: number, agentType?: AgentTypeEnum, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BrandNameDTO>>>;
  public apiAgentManagementGetAllBrandNamesGet(agentId?: number, agentType?: AgentTypeEnum, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BrandNameDTO>>>;
  public apiAgentManagementGetAllBrandNamesGet(agentId?: number, agentType?: AgentTypeEnum, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



      let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
      if (agentId !== undefined && agentId !== null) {
          queryParameters = queryParameters.set('agentId', <any>agentId);
      }
      if (agentType !== undefined && agentType !== null) {
          queryParameters = queryParameters.set('agentType', <any>agentType);
      }

      let headers = this.defaultHeaders;

      // authentication (Bearer) required
      if (this.configuration.accessToken) {
          const accessToken = typeof this.configuration.accessToken === 'function'
              ? this.configuration.accessToken()
              : this.configuration.accessToken;
          headers = headers.set('Authorization', 'Bearer ' + accessToken);
      }
      // authentication (apiKey) required
      if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
          headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
      }

      // to determine the Accept header
      let httpHeaderAccepts: string[] = [
          'text/plain',
          'application/json',
          'text/json'
      ];
      const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
      if (httpHeaderAcceptSelected != undefined) {
          headers = headers.set('Accept', httpHeaderAcceptSelected);
      }

      // to determine the Content-Type header
      const consumes: string[] = [
      ];

      return this.httpClient.request<Array<BrandNameDTO>>('get',`${this.basePath}/api/Agent/Management/GetAllBrandNames`,
          {
              params: queryParameters,
              withCredentials: this.configuration.withCredentials,
              headers: headers,
              observe: observe,
              reportProgress: reportProgress
          }
      );
  }

    /**
     * Agent management -   Important: UserId - the user Id of the user who&#x27;s logged in. If left blank, it will retrieve all the agents and subagents regardless of the Agent level.   so make sure to pass the UserId.
     * 
     * @param pageSize 
     * @param pageNumber 
     * @param userId 
     * @param searchKeyword 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementListGet(pageSize?: number, pageNumber?: number, userId?: number, searchKeyword?: string, observe?: 'body', reportProgress?: boolean): Observable<AgentListDTO>;
    public apiAgentManagementListGet(pageSize?: number, pageNumber?: number, userId?: number, searchKeyword?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentListDTO>>;
    public apiAgentManagementListGet(pageSize?: number, pageNumber?: number, userId?: number, searchKeyword?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentListDTO>>;
    public apiAgentManagementListGet(pageSize?: number, pageNumber?: number, userId?: number, searchKeyword?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('PageNumber', <any>pageNumber);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('UserId', <any>userId);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('SearchKeyword', <any>searchKeyword);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentListDTO>('get',`${this.basePath}/api/Agent/Management/List`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
    /**
     * Create Agent Balance transfer request
     * 
     * @param requestee 
     * @param clientId 
     * @param amount 
     * @param remarks 
     * @param requestedByAdmin 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentRequestBalanceForTransferCreatePost(requestee: number, clientId: number, amount: number, remarks?: string, requestedByAdmin?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentRequestForBalanceTransferDTO>;
    public apiAgentRequestBalanceForTransferCreatePost(requestee: number, clientId: number, amount: number, remarks?: string, requestedByAdmin?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentRequestForBalanceTransferDTO>>;
    public apiAgentRequestBalanceForTransferCreatePost(requestee: number, clientId: number, amount: number, remarks?: string, requestedByAdmin?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentRequestForBalanceTransferDTO>>;
    public apiAgentRequestBalanceForTransferCreatePost(requestee: number, clientId: number, amount: number, remarks?: string, requestedByAdmin?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (requestee === null || requestee === undefined) {
            throw new Error('Required parameter requestee was null or undefined when calling apiAgentRequestBalanceForTransferCreatePost.');
        }

        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling apiAgentRequestBalanceForTransferCreatePost.');
        }

        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling apiAgentRequestBalanceForTransferCreatePost.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestee !== undefined && requestee !== null) {
            queryParameters = queryParameters.set('Requestee', <any>requestee);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('ClientId', <any>clientId);
        }
        if (amount !== undefined && amount !== null) {
            queryParameters = queryParameters.set('Amount', <any>amount);
        }
        if (remarks !== undefined && remarks !== null) {
            queryParameters = queryParameters.set('Remarks', <any>remarks);
        }
        if (requestedByAdmin !== undefined && requestedByAdmin !== null) {
            queryParameters = queryParameters.set('RequestedByAdmin', <any>requestedByAdmin);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentRequestForBalanceTransferDTO>('post',`${this.basePath}/api/Agent/Request/BalanceForTransfer/Create`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves Client-Agent-PaymentChannel Summary for Agent balance transfer approval
     * 
     * @param agentId AgentId of the Requestee
     * @param clientId ClientId of the selected client
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentRequestBalanceTransFerApproveGetClientPaymentChannelsGet(agentId?: number, clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentClientChannelSummaryDTO>;
    public apiAgentRequestBalanceTransFerApproveGetClientPaymentChannelsGet(agentId?: number, clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentClientChannelSummaryDTO>>;
    public apiAgentRequestBalanceTransFerApproveGetClientPaymentChannelsGet(agentId?: number, clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentClientChannelSummaryDTO>>;
    public apiAgentRequestBalanceTransFerApproveGetClientPaymentChannelsGet(agentId?: number, clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentClientChannelSummaryDTO>('get',`${this.basePath}/api/Agent/Request/BalanceTransFer/Approve/GetClientPaymentChannels`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Decline Transfer Balance Request
     * 
     * @param requestId 
     * @param approvedBy 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentRequestBalanceTransferDeclinePut(requestId?: string, approvedBy?: number, observe?: 'body', reportProgress?: boolean): Observable<DeclineResponseDTO>;
    public apiAgentRequestBalanceTransferDeclinePut(requestId?: string, approvedBy?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeclineResponseDTO>>;
    public apiAgentRequestBalanceTransferDeclinePut(requestId?: string, approvedBy?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeclineResponseDTO>>;
    public apiAgentRequestBalanceTransferDeclinePut(requestId?: string, approvedBy?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestId !== undefined && requestId !== null) {
            queryParameters = queryParameters.set('RequestId', <any>requestId);
        }
        if (approvedBy !== undefined && approvedBy !== null) {
            queryParameters = queryParameters.set('ApprovedBy', <any>approvedBy);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DeclineResponseDTO>('put',`${this.basePath}/api/Agent/Request/BalanceTransfer/Decline`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the list of Balance transfer request
     * 
     * @param agentId Optional: AgentId/Requestee
     * @param status Required: 1-Pending, 2-Completed/Declined
     * @param keywords Optional: Search Keywords
     * @param startDate 
     * @param endDate 
     * @param pageNumber 
     * @param pageSize 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentRequestBalanceTransFerListGet(agentId?: number, status?: AgentBalanceTransfer, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<BalanceTransferListDTO>;
    public apiAgentRequestBalanceTransFerListGet(agentId?: number, status?: AgentBalanceTransfer, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BalanceTransferListDTO>>;
    public apiAgentRequestBalanceTransFerListGet(agentId?: number, status?: AgentBalanceTransfer, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BalanceTransferListDTO>>;
    public apiAgentRequestBalanceTransFerListGet(agentId?: number, status?: AgentBalanceTransfer, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (keywords !== undefined && keywords !== null) {
            queryParameters = queryParameters.set('keywords', <any>keywords);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BalanceTransferListDTO>('get',`${this.basePath}/api/Agent/Request/BalanceTransFer/List`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Decline Transfer Balance Request
     * 
     * @param body 1. RequestId - RequestId of the cerated transaction for balance transfer.
2. ApprovedBy - Approver / User Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
public apiAgentRequestBalanceTransferApprovePut(body?: ApproveRequestBalanceTransfer, observe?: 'body', reportProgress?: boolean): Observable<ApproveResponseDTO>;
public apiAgentRequestBalanceTransferApprovePut(body?: ApproveRequestBalanceTransfer, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApproveResponseDTO>>;
public apiAgentRequestBalanceTransferApprovePut(body?: ApproveRequestBalanceTransfer, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApproveResponseDTO>>;
public apiAgentRequestBalanceTransferApprovePut(body?: ApproveRequestBalanceTransfer, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.accessToken) {
        const accessToken = typeof this.configuration.accessToken === 'function'
            ? this.configuration.accessToken()
            : this.configuration.accessToken;
        headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // authentication (apiKey) required
    if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
        headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
        'text/plain',
        'application/json',
        'text/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
        headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
        'application/json',
        'text/json',
        'application/_*+json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
        headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.request<ApproveResponseDTO>('put',`${this.basePath}/api/Agent/Request/BalanceTransfer/Approve`,
        {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        }
    );
}

/**
     * Request for Remittance
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
public apiAgentCardTransactionRemittanceRequestPost(body?: CardTransactionRequest, observe?: 'body', reportProgress?: boolean): Observable<AgentCardTransaction>;
public apiAgentCardTransactionRemittanceRequestPost(body?: CardTransactionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentCardTransaction>>;
public apiAgentCardTransactionRemittanceRequestPost(body?: CardTransactionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentCardTransaction>>;
public apiAgentCardTransactionRemittanceRequestPost(body?: CardTransactionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


    let headers = this.defaultHeaders;

    // authentication (Bearer) required
    if (this.configuration.accessToken) {
        const accessToken = typeof this.configuration.accessToken === 'function'
            ? this.configuration.accessToken()
            : this.configuration.accessToken;
        headers = headers.set('Authorization', 'Bearer ' + accessToken);
    }
    // authentication (apiKey) required
    if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
        headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
        'text/plain',
        'application/json',
        'text/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
        headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
        'application/json',
        'text/json',
        'application/_*+json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
        headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.request<AgentCardTransaction>('post',`${this.basePath}/api/Agent/Card/Transaction/Remittance/Request`,
        {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        }
    );
}

    /**
     * Retrieve list of Agent&#x27;s Card.
     * 
     * @param agentId Required
     * @param pageNumber Optional
     * @param pageSize Optional
     * @param searchKeywords Optional: AccountName | AccountNumber | BankName | NickName
     * @param type Agent&#x27;s Bank Type
     * @param cardId Optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardListGet(agentId?: number, pageNumber?: number, pageSize?: number, searchKeywords?: string, type?: AgentBankType, cardId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<CardListDTO>>;
    public apiAgentCardListGet(agentId?: number, pageNumber?: number, pageSize?: number, searchKeywords?: string, type?: AgentBankType, cardId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CardListDTO>>>;
    public apiAgentCardListGet(agentId?: number, pageNumber?: number, pageSize?: number, searchKeywords?: string, type?: AgentBankType, cardId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CardListDTO>>>;
    public apiAgentCardListGet(agentId?: number, pageNumber?: number, pageSize?: number, searchKeywords?: string, type?: AgentBankType, cardId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (searchKeywords !== undefined && searchKeywords !== null) {
            queryParameters = queryParameters.set('searchKeywords', <any>searchKeywords);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', <any>type);
        }
        if (cardId !== undefined && cardId !== null) {
            queryParameters = queryParameters.set('cardId', <any>cardId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CardListDTO>>('get',`${this.basePath}/api/Agent/Card/List`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the list of Remittance per Clients
     * 
     * @param agentId required
     * @param keywords optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceListOfClientsGet(agentId?: number, keywords?: string, observe?: 'body', reportProgress?: boolean): Observable<AgentRemittanceListOfClientSummary>;
    public apiAgentCardTransactionRemittanceListOfClientsGet(agentId?: number, keywords?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentRemittanceListOfClientSummary>>;
    public apiAgentCardTransactionRemittanceListOfClientsGet(agentId?: number, keywords?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentRemittanceListOfClientSummary>>;
    public apiAgentCardTransactionRemittanceListOfClientsGet(agentId?: number, keywords?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (keywords !== undefined && keywords !== null) {
            queryParameters = queryParameters.set('keywords', <any>keywords);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentRemittanceListOfClientSummary>('get',`${this.basePath}/api/Agent/Card/Transaction/Remittance/ListOfClients`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Dashobard Top Cards, List of Clients and Comms per client
     * 
     * @param agentId Required
     * @param searchKeyword optional:Search by Client Name
     * @param pageNumber 
     * @param pageSize 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentDashboardTopCardsGet(agentId?: number, searchKeyword?: string, pageNumber?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentTopCardDTO>;
    public apiAgentDashboardTopCardsGet(agentId?: number, searchKeyword?: string, pageNumber?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentTopCardDTO>>;
    public apiAgentDashboardTopCardsGet(agentId?: number, searchKeyword?: string, pageNumber?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentTopCardDTO>>;
    public apiAgentDashboardTopCardsGet(agentId?: number, searchKeyword?: string, pageNumber?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentTopCardDTO>('get',`${this.basePath}/api/Agent/Dashboard/TopCards`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

     /**
     * Create/Register Agent Cards
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
     public apiAgentCardCreatePost(body?: CardRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<AgentCard>;
     public apiAgentCardCreatePost(body?: CardRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentCard>>;
     public apiAgentCardCreatePost(body?: CardRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentCard>>;
     public apiAgentCardCreatePost(body?: CardRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<AgentCard>('post',`${this.basePath}/api/Agent/Card/Create`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
    /**
     * Retrieves dashboard Total Commission by Today, Yesterday, thisWeek, thisMonth
     * 
     * @param agentId Required
     * @param searchByDate Required: Acceptable Enum values: 0-Today, 1-Yesterday, 2-thisWeek,3-lastWeek, 4-thisMonth, 5-lastMonth
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentDashboardTotalCommissionsGet(agentId?: number, searchByDate?: DateFilter, observe?: 'body', reportProgress?: boolean): Observable<DashboardTotalCommDTO>;
    public apiAgentDashboardTotalCommissionsGet(agentId?: number, searchByDate?: DateFilter, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DashboardTotalCommDTO>>;
    public apiAgentDashboardTotalCommissionsGet(agentId?: number, searchByDate?: DateFilter, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DashboardTotalCommDTO>>;
    public apiAgentDashboardTotalCommissionsGet(agentId?: number, searchByDate?: DateFilter, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (searchByDate !== undefined && searchByDate !== null) {
            queryParameters = queryParameters.set('searchByDate', <any>searchByDate);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<DashboardTotalCommDTO>('get',`${this.basePath}/api/Agent/Dashboard/TotalCommissions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve Agent Transaction logs and Commissions
     * 
     * @param agentId Required
     * @param clientName Optional
     * @param searchKeyword Optional: Vendorname, ChannelName, InternalTransactionNumber
     * @param startDate optional
     * @param endDate optional
     * @param pageNumber optional Default:1
     * @param pageSize optional Default:100
     * @param generateCSV 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentReportsTransactionLogsGet(agentId?: number, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'body', reportProgress?: boolean): Observable<AgentReportTransactionLog>;
    public apiAgentReportsTransactionLogsGet(agentId?: number, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentReportTransactionLog>>;
    public apiAgentReportsTransactionLogsGet(agentId?: number, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentReportTransactionLog>>;
    public apiAgentReportsTransactionLogsGet(agentId?: number, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (clientName !== undefined && clientName !== null) {
            queryParameters = queryParameters.set('clientName', <any>clientName);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (generateCSV !== undefined && generateCSV !== null) {
            queryParameters = queryParameters.set('generateCSV', <any>generateCSV);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentReportTransactionLog>('get',`${this.basePath}/api/Agent/Reports/TransactionLogs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves Account Flow Records
     * 
     * @param agentId Required
     * @param channelName Optional
     * @param clientName Optional
     * @param searchKeyword Optional
     * @param startDate Optional
     * @param endDate Optional
     * @param pageNumber Optional
     * @param pageSize Optional
     * @param generateCSV Default:false, set to true to export CSV
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentReportsAccountsFlowGet(agentId?: number, channelName?: string, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ReportAccountFlowSummary>;
    public apiAgentReportsAccountsFlowGet(agentId?: number, channelName?: string, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReportAccountFlowSummary>>;
    public apiAgentReportsAccountsFlowGet(agentId?: number, channelName?: string, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReportAccountFlowSummary>>;
    public apiAgentReportsAccountsFlowGet(agentId?: number, channelName?: string, clientName?: string, searchKeyword?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (channelName !== undefined && channelName !== null) {
            queryParameters = queryParameters.set('channelName', <any>channelName);
        }
        if (clientName !== undefined && clientName !== null) {
            queryParameters = queryParameters.set('clientName', <any>clientName);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (generateCSV !== undefined && generateCSV !== null) {
            queryParameters = queryParameters.set('generateCSV', <any>generateCSV);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ReportAccountFlowSummary>('get',`${this.basePath}/api/Agent/Reports/AccountsFlow`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all available channels.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementGetAllChannelsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<AgentChannelsDTO>>;
    public apiAgentManagementGetAllChannelsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AgentChannelsDTO>>>;
    public apiAgentManagementGetAllChannelsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AgentChannelsDTO>>>;
    public apiAgentManagementGetAllChannelsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AgentChannelsDTO>>('get',`${this.basePath}/api/Agent/Management/GetAllChannels`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remittance List
     * 
     * @param agentId Optional for Mother side, Required in Agent side
     * @param status optional: 0-All, 1-Pending, 2-Declined, 3-Completed, 4-Processing
     * @param keywords optional:TrnasactionNo,RemittanceId, AccountName, BankName, AccountNumber,Nickname
     * @param startDate optional
     * @param endDate optional
     * @param pageNumber optional
     * @param pageSize optional
     * @param generateCSV bool value to generate csv file
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceListGet(agentId?: number, status?: AgentRemittance, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'body', reportProgress?: boolean): Observable<AgentRemittanceListDTO>;
    public apiAgentCardTransactionRemittanceListGet(agentId?: number, status?: AgentRemittance, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentRemittanceListDTO>>;
    public apiAgentCardTransactionRemittanceListGet(agentId?: number, status?: AgentRemittance, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentRemittanceListDTO>>;
    public apiAgentCardTransactionRemittanceListGet(agentId?: number, status?: AgentRemittance, keywords?: string, startDate?: Date, endDate?: Date, pageNumber?: number, pageSize?: number, generateCSV?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (keywords !== undefined && keywords !== null) {
            queryParameters = queryParameters.set('keywords', <any>keywords);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (generateCSV !== undefined && generateCSV !== null) {
            queryParameters = queryParameters.set('generateCSV', <any>generateCSV);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentRemittanceListDTO>('get',`${this.basePath}/api/Agent/Card/Transaction/Remittance/List`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves list of Agents Remittance Summary
     * 
     * @param agentId Required
     * @param keywords optional
     * @param pageNumber optional
     * @param pageSize optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceListOfAgentsGet(agentId?: number, keywords?: string, pageNumber?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentRemittanceListSummaryDTO>;
    public apiAgentCardTransactionRemittanceListOfAgentsGet(agentId?: number, keywords?: string, pageNumber?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentRemittanceListSummaryDTO>>;
    public apiAgentCardTransactionRemittanceListOfAgentsGet(agentId?: number, keywords?: string, pageNumber?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentRemittanceListSummaryDTO>>;
    public apiAgentCardTransactionRemittanceListOfAgentsGet(agentId?: number, keywords?: string, pageNumber?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('agentId', <any>agentId);
        }
        if (keywords !== undefined && keywords !== null) {
            queryParameters = queryParameters.set('keywords', <any>keywords);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AgentRemittanceListSummaryDTO>('get',`${this.basePath}/api/Agent/Card/Transaction/Remittance/ListOfAgents`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Admin Decline Remittance Request
     * 
     * @param remittanceId Required: Remittance Id
     * @param remarks Required: Remarks why the Request is declined
     * @param approvedBy Required: UserId of the the logged user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceDeclinePut(remittanceId?: string, remarks?: string, approvedBy?: number, observe?: 'body', reportProgress?: boolean): Observable<RemittnaceDeclineDTO>;
    public apiAgentCardTransactionRemittanceDeclinePut(remittanceId?: string, remarks?: string, approvedBy?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RemittnaceDeclineDTO>>;
    public apiAgentCardTransactionRemittanceDeclinePut(remittanceId?: string, remarks?: string, approvedBy?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RemittnaceDeclineDTO>>;
    public apiAgentCardTransactionRemittanceDeclinePut(remittanceId?: string, remarks?: string, approvedBy?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (remittanceId !== undefined && remittanceId !== null) {
            queryParameters = queryParameters.set('remittanceId', <any>remittanceId);
        }
        if (remarks !== undefined && remarks !== null) {
            queryParameters = queryParameters.set('remarks', <any>remarks);
        }
        if (approvedBy !== undefined && approvedBy !== null) {
            queryParameters = queryParameters.set('approvedBy', <any>approvedBy);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RemittnaceDeclineDTO>('put',`${this.basePath}/api/Agent/Card/Transaction/Remittance/Decline`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Approved/Released Remittance request
     * 
     * @param transactionId 
     * @param withdrawalCount 
     * @param confirmAmount 
     * @param referenceNumber 
     * @param source 
     * @param depositSlips 
     * @param approvedBy 
     * @param modeofPayment 
     * @param remarks 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceApprovePutForm(transactionId?: number, withdrawalCount?: number, confirmAmount?: number, referenceNumber?: string, source?: number, depositSlips?: Array<Blob>, approvedBy?: number, modeofPayment?: AgentBankType, remarks?: string, observe?: 'body', reportProgress?: boolean): Observable<AgentApprovedRemittanceRequest>;
    public apiAgentCardTransactionRemittanceApprovePutForm(transactionId?: number, withdrawalCount?: number, confirmAmount?: number, referenceNumber?: string, source?: number, depositSlips?: Array<Blob>, approvedBy?: number, modeofPayment?: AgentBankType, remarks?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentApprovedRemittanceRequest>>;
    public apiAgentCardTransactionRemittanceApprovePutForm(transactionId?: number, withdrawalCount?: number, confirmAmount?: number, referenceNumber?: string, source?: number, depositSlips?: Array<Blob>, approvedBy?: number, modeofPayment?: AgentBankType, remarks?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentApprovedRemittanceRequest>>;
    public apiAgentCardTransactionRemittanceApprovePutForm(transactionId?: number, withdrawalCount?: number, confirmAmount?: number, referenceNumber?: string, source?: number, depositSlips?: Array<Blob>, approvedBy?: number, modeofPayment?: AgentBankType, remarks?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (transactionId !== undefined) {
            formParams = formParams.append('TransactionId', <any>transactionId) as any || formParams;
        }
        if (withdrawalCount !== undefined) {
            formParams = formParams.append('WithdrawalCount', <any>withdrawalCount) as any || formParams;
        }
        if (confirmAmount !== undefined) {
            formParams = formParams.append('ConfirmAmount', <any>confirmAmount) as any || formParams;
        }
        if (referenceNumber !== undefined) {
            formParams = formParams.append('ReferenceNumber', <any>referenceNumber) as any || formParams;
        }
        if (source !== undefined) {
            formParams = formParams.append('source', <any>source) as any || formParams;
        }
        if (depositSlips) {
            depositSlips.forEach((element) => {
                formParams = formParams.append('DepositSlips', <any>element) as any || formParams;
            })
        }
        if (approvedBy !== undefined) {
            formParams = formParams.append('ApprovedBy', <any>approvedBy) as any || formParams;
        }
        if (modeofPayment !== undefined) {
            formParams = formParams.append('ModeofPayment', <any>modeofPayment) as any || formParams;
        }
        if (remarks !== undefined) {
            formParams = formParams.append('Remarks', <any>remarks) as any || formParams;
        }

        return this.httpClient.request<AgentApprovedRemittanceRequest>('put',`${this.basePath}/api/Agent/Card/Transaction/Remittance/Approve`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change Pending Status to Processing
     * 
     * @param remittanceId Required
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceProcessingPut(remittanceId?: string, observe?: 'body', reportProgress?: boolean): Observable<RemittnaceDeclineDTO>;
    public apiAgentCardTransactionRemittanceProcessingPut(remittanceId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RemittnaceDeclineDTO>>;
    public apiAgentCardTransactionRemittanceProcessingPut(remittanceId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RemittnaceDeclineDTO>>;
    public apiAgentCardTransactionRemittanceProcessingPut(remittanceId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (remittanceId !== undefined && remittanceId !== null) {
            queryParameters = queryParameters.set('remittanceId', <any>remittanceId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RemittnaceDeclineDTO>('put',`${this.basePath}/api/Agent/Card/Transaction/Remittance/Processing`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Request for Agent Remittance
     * 
     * @param agentId 
     * @param amount 
     * @param withdrawalFee 
     * @param totalAmount 
     * @param remittanceMethod 
     * @param cardId 
     * @param remarks 
     * @param authorizedPerson 
     * @param idType 
     * @param idNumber 
     * @param uploadId 
     * @param uploadAuthorizationLetter 
     * @param requestedbyAdmin 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentCardTransactionRemittanceRequestPostForm(agentId?: number, amount?: number, withdrawalFee?: number, totalAmount?: number, remittanceMethod?: AgentBankType, cardId?: number, remarks?: string, authorizedPerson?: string, idType?: AgentIdType, idNumber?: string, uploadId?: Array<Blob>, uploadAuthorizationLetter?: Array<Blob>, requestedbyAdmin?: number, observe?: 'body', reportProgress?: boolean): Observable<AgentCardRequestRemittance>;
    public apiAgentCardTransactionRemittanceRequestPostForm(agentId?: number, amount?: number, withdrawalFee?: number, totalAmount?: number, remittanceMethod?: AgentBankType, cardId?: number, remarks?: string, authorizedPerson?: string, idType?: AgentIdType, idNumber?: string, uploadId?: Array<Blob>, uploadAuthorizationLetter?: Array<Blob>, requestedbyAdmin?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AgentCardRequestRemittance>>;
    public apiAgentCardTransactionRemittanceRequestPostForm(agentId?: number, amount?: number, withdrawalFee?: number, totalAmount?: number, remittanceMethod?: AgentBankType, cardId?: number, remarks?: string, authorizedPerson?: string, idType?: AgentIdType, idNumber?: string, uploadId?: Array<Blob>, uploadAuthorizationLetter?: Array<Blob>, requestedbyAdmin?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentCardRequestRemittance>>;
    public apiAgentCardTransactionRemittanceRequestPostForm(agentId?: number, amount?: number, withdrawalFee?: number, totalAmount?: number, remittanceMethod?: AgentBankType, cardId?: number, remarks?: string, authorizedPerson?: string, idType?: AgentIdType, idNumber?: string, uploadId?: Array<Blob>, uploadAuthorizationLetter?: Array<Blob>, requestedbyAdmin?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {














        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (agentId !== undefined) {
            formParams = formParams.append('AgentId', <any>agentId) as any || formParams;
        }
        if (amount !== undefined) {
            formParams = formParams.append('Amount', <any>amount) as any || formParams;
        }
        if (withdrawalFee !== undefined) {
            formParams = formParams.append('WithdrawalFee', <any>withdrawalFee) as any || formParams;
        }
        if (totalAmount !== undefined) {
            formParams = formParams.append('TotalAmount', <any>totalAmount) as any || formParams;
        }
        if (remittanceMethod !== undefined) {
            formParams = formParams.append('RemittanceMethod', <any>remittanceMethod) as any || formParams;
        }
        if (cardId !== undefined) {
            formParams = formParams.append('CardId', <any>cardId) as any || formParams;
        }
        if (remarks !== undefined) {
            formParams = formParams.append('Remarks', <any>remarks) as any || formParams;
        }
        if (authorizedPerson !== undefined) {
            formParams = formParams.append('AuthorizedPerson', <any>authorizedPerson) as any || formParams;
        }
        if (idType !== undefined) {
            formParams = formParams.append('IdType', <any>idType) as any || formParams;
        }
        if (idNumber !== undefined) {
            formParams = formParams.append('IdNumber', <any>idNumber) as any || formParams;
        }
        if (uploadId) {
            uploadId.forEach((element) => {
                formParams = formParams.append('UploadId', <any>element) as any || formParams;
            })
        }
        if (uploadAuthorizationLetter) {
            uploadAuthorizationLetter.forEach((element) => {
                formParams = formParams.append('UploadAuthorizationLetter', <any>element) as any || formParams;
            })
        }
        if (requestedbyAdmin !== undefined) {
            formParams = formParams.append('RequestedbyAdmin', <any>requestedbyAdmin) as any || formParams;
        }

        return this.httpClient.request<AgentCardRequestRemittance>('post',`${this.basePath}/api/Agent/Card/Transaction/Remittance/Request`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * An Admin - retrieves all agents except Elite agent
     * 
     * @param agentNames Filter by Agentname or Username
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiAgentManagementGetAllAgentsForAdminGet(agentNames?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AgentUsernameDTO>>;
    public apiAgentManagementGetAllAgentsForAdminGet(agentNames?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AgentUsernameDTO>>>;
    public apiAgentManagementGetAllAgentsForAdminGet(agentNames?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AgentUsernameDTO>>>;
    public apiAgentManagementGetAllAgentsForAdminGet(agentNames?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentNames !== undefined && agentNames !== null) {
            queryParameters = queryParameters.set('agentNames', <any>agentNames);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AgentUsernameDTO>>('get',`${this.basePath}/api/Agent/Management/GetAllAgentsForAdmin`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    

    



    


}
