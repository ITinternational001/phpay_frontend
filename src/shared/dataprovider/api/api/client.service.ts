/**
 * DynastyGateway API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

 import { Inject, Injectable, Optional }                      from '@angular/core';
 import { HttpClient, HttpHeaders, HttpParams,
          HttpResponse, HttpEvent }                           from '@angular/common/http';
 import { CustomHttpUrlEncodingCodec }                        from '../encoder';
 
 import { Observable }                                        from 'rxjs';
 
 import { BankDTO } from '../model/bankDTO';
 import { CardDTO } from '../model/cardDTO';
 import { CardTransactionDTO } from '../model/cardTransactionDTO';
 import { ClientConfigureFeesDTO } from '../model/clientConfigureFeesDTO';
 import { ClientDTO } from '../model/clientDTO';
 import { ClientWithdrawalsDTO } from '../model/clientWithdrawalsDTO';
 import { ClientWithdrawalsHistoryDTO } from '../model/clientWithdrawalsHistoryDTO';
 import { CreateCardRequestDTO } from '../model/createCardRequestDTO';
 import { CreateCardWithdrawalRequestDTO } from '../model/createCardWithdrawalRequestDTO';
 import { CreateClientRequestDTO } from '../model/createClientRequestDTO';
 import { CreateWithdrawalFeesRequestDTO } from '../model/createWithdrawalFeesRequestDTO';
 import { ProblemDetails } from '../model/problemDetails';
 import { RemittanceDTO } from '../model/remittanceDTO';
 import { StatusEnum } from '../model/statusEnum';
 import { UpdateCardRequestDTO } from '../model/updateCardRequestDTO';
 import { UpdateCardWithdrawalRequestDTO } from '../model/updateCardWithdrawalRequestDTO';
 import { UpdateClientRequestDTO } from '../model/updateClientRequestDTO';
 import { UpdateWithdrawalFeesRequestDTO } from '../model/updateWithdrawalFeesRequestDTO';
 import { WithdrawalFeeDTO } from '../model/withdrawalFeeDTO';
 import { WithdrawalTypeEnum } from '../model/withdrawalTypeEnum';
 
 import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
 import { Configuration }                                     from '../configuration';
import { environment } from 'src/environments/environment';
import { ClientAggregatesDTO } from '../model/clientAggregatesDTO';
import { IncomeStatementChartDataRequestDTO } from '../model/incomeStatementChartDataRequestDTO';
import { IncomeStatementChart } from '../model/incomeStatementChart';
import { ClientBalanceForEachChannelDTO } from '../model/clientBalanceForEachChannelDTO';
import { WithdrawalStatusEnum } from '../model/withdrawalStatusEnum';
import { ClientBalanceResultDTO } from '../model/clientBalanceResultDTO';
import { SuccessRate } from '../model/successRate';
import { SuccessRateSummary } from '../model/successRateSummary';
import { ClientWalletDTO } from '../model/clientWalletDTO';
import { ClientCOFundsBalanceDTO } from '../model/clientCOFundsBalanceDTO';
import { DailyTransactionPieChartDataRequestDTO } from '../model/dailyTransactionPieChartDataRequestDTO';
import { DailyTransactionPieChart } from '../model/dailyTransactionPieChart';
import { PaymentChannelSummary } from '../model/paymentChannelSummary';
import { ValidIDEnum } from '../model/validIDEnum';
import { RemittanceListDTO } from './remittanceListDTO';
import { ClientWalletListDTO } from '../model/clientWalletListDTO';
import { ClientCardListDTO } from '../model/clientCardListDTO';
 
 
 @Injectable()
 export class ClientService {
 
    protected basePath = environment.basePath;
    public token = sessionStorage.getItem("token") || '';
    public defaultHeaders = new HttpHeaders({
        'X-API-KEY': environment.APIkey,
        'Authorization': this.token ? `Bearer ${this.token}` : '',
    });
     public configuration = new Configuration();
 
     constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
         if (basePath) {
             this.basePath = basePath;
         }
         if (configuration) {
             this.configuration = configuration;
             this.basePath = basePath || configuration.basePath || this.basePath;
         }
     }
 
     /**
      * @param consumes string[] mime-types
      * @return true: consumes contains 'multipart/form-data', false: otherwise
      */
     private canConsumeForm(consumes: string[]): boolean {
         const form = 'multipart/form-data';
         for (const consume of consumes) {
             if (form === consume) {
                 return true;
             }
         }
         return false;
     }
 
 

      /**
     * Update the status of the withdrawal request of the client. Only authorized users can update the status of the request.
     * 
     * @param transactionNumber 
     * @param referenceNumber 
     * @param status 
     * @param approverId 
     * @param clientId 
     * @param transactionCount 
     * @param totalAmount 
     * @param cardIdMotherFundSource 
     * @param remarks 
     * @param receipts 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
      public apiClientChangeWithdrawalRequestStatusPostForm(transactionNumber?: string, referenceNumber?: string, status?: WithdrawalStatusEnum, approverId?: number, clientId?: string, transactionCount?: number, totalAmount?: number, cardIdMotherFundSource?: number, remarks?: string, receipts?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<CardTransactionDTO>;
      public apiClientChangeWithdrawalRequestStatusPostForm(transactionNumber?: string, referenceNumber?: string, status?: WithdrawalStatusEnum, approverId?: number, clientId?: string, transactionCount?: number, totalAmount?: number, cardIdMotherFundSource?: number, remarks?: string, receipts?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CardTransactionDTO>>;
      public apiClientChangeWithdrawalRequestStatusPostForm(transactionNumber?: string, referenceNumber?: string, status?: WithdrawalStatusEnum, approverId?: number, clientId?: string, transactionCount?: number, totalAmount?: number, cardIdMotherFundSource?: number, remarks?: string, receipts?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CardTransactionDTO>>;
      public apiClientChangeWithdrawalRequestStatusPostForm(transactionNumber?: string, referenceNumber?: string, status?: WithdrawalStatusEnum, approverId?: number, clientId?: string, transactionCount?: number, totalAmount?: number, cardIdMotherFundSource?: number, remarks?: string, receipts?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
  
          let headers = this.defaultHeaders;
  
          // authentication (Bearer) required
          if (this.configuration.accessToken) {
              const accessToken = typeof this.configuration.accessToken === 'function'
                  ? this.configuration.accessToken()
                  : this.configuration.accessToken;
              headers = headers.set('Authorization', 'Bearer ' + accessToken);
          }
          // authentication (apiKey) required
          if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
              headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
          }
  
          // to determine the Accept header
          let httpHeaderAccepts: string[] = [
              'text/plain',
              'application/json',
              'text/json'
          ];
          const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
          if (httpHeaderAcceptSelected != undefined) {
              headers = headers.set('Accept', httpHeaderAcceptSelected);
          }
  
          // to determine the Content-Type header
          const consumes: string[] = [
              'multipart/form-data'
          ];
  
          const canConsumeForm = this.canConsumeForm(consumes);
  
          let formParams: { append(param: string, value: any): void; };
          let useForm = false;
          let convertFormParamsToString = false;
          // use FormData to transmit files using content-type "multipart/form-data"
          // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
          useForm = canConsumeForm;
          if (useForm) {
              formParams = new FormData();
          } else {
              formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
          }
  
          if (transactionNumber !== undefined) {
              formParams = formParams.append('TransactionNumber', <any>transactionNumber) as any || formParams;
          }
          if (referenceNumber !== undefined) {
              formParams = formParams.append('ReferenceNumber', <any>referenceNumber) as any || formParams;
          }
          if (status !== undefined) {
              formParams = formParams.append('Status', <any>status) as any || formParams;
          }
          if (approverId !== undefined) {
              formParams = formParams.append('ApproverId', <any>approverId) as any || formParams;
          }
          if (clientId !== undefined) {
              formParams = formParams.append('ClientId', <any>clientId) as any || formParams;
          }
          if (transactionCount !== undefined) {
              formParams = formParams.append('TransactionCount', <any>transactionCount) as any || formParams;
          }
          if (totalAmount !== undefined) {
              formParams = formParams.append('TotalAmount', <any>totalAmount) as any || formParams;
          }
          if (cardIdMotherFundSource !== undefined) {
              formParams = formParams.append('CardIdMotherFundSource', <any>cardIdMotherFundSource) as any || formParams;
          }
          if (remarks !== undefined) {
              formParams = formParams.append('Remarks', <any>remarks) as any || formParams;
          }
          if (receipts) {
              receipts.forEach((element) => {
                  formParams = formParams.append('receipts', <any>element) as any || formParams;
              })
          }
  
          return this.httpClient.request<CardTransactionDTO>('post',`${this.basePath}/api/Client/ChangeWithdrawalRequestStatus`,
              {
                  body: convertFormParamsToString ? formParams.toString() : formParams,
                  withCredentials: this.configuration.withCredentials,
                  headers: headers,
                  observe: observe,
                  reportProgress: reportProgress
              }
          );
      }

 
     /**
      * Creates a card that will be used by the client as the destination account for remittances.
      * 
      * @param body The request body contains the following:
  1. ClientId 
  2. CardType (1 - Bank, 2 - USDT, 3 - EWallet )
  3. BankName
  4. AccountNumber
  5. NickName
  6. BinanceId
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientCreateCardPost(body?: CreateCardRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<CardDTO>;
     public apiClientCreateCardPost(body?: CreateCardRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CardDTO>>;
     public apiClientCreateCardPost(body?: CreateCardRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CardDTO>>;
     public apiClientCreateCardPost(body?: CreateCardRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<CardDTO>('post',`${this.basePath}/api/Client/CreateCard`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Create a new client
      * 
      * @param body The request body contains the following:
    1. Name 
    2. ProviderId
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientCreateClientPost(body?: CreateClientRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<ClientDTO>;
     public apiClientCreateClientPost(body?: CreateClientRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientDTO>>;
     public apiClientCreateClientPost(body?: CreateClientRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientDTO>>;
     public apiClientCreateClientPost(body?: CreateClientRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<ClientDTO>('post',`${this.basePath}/api/Client/CreateClient`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Create a new withdrawal fee for a client that will be used in remittance requests.
      * 
      * @param body The request body contains the following:
 1. VendorId - Vendor&#x27;s id
 2. ClientId - Client&#x27;s id
 3. Method - Remittance Method  ( 1 -  thru BANK,    2 - thru Binance, 3 - thru cash pickup )
 4. FeeOnTopPercent - Fee On Top in percentage
 5. FeeOnTopFixed  - Fee On Top in fixed amount
 6. FeeAtCostPercent - Fee At Cost in percentage
 7. FeeAtCostFixed - Fee At Cost in fixed amount
 8. Status - status of the withdrawal fee (  1 - Active, 2 - Inactive, 3 - Deleted )
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientCreateWithdrawalFeePost(body?: CreateWithdrawalFeesRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<WithdrawalFeeDTO>;
     public apiClientCreateWithdrawalFeePost(body?: CreateWithdrawalFeesRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WithdrawalFeeDTO>>;
     public apiClientCreateWithdrawalFeePost(body?: CreateWithdrawalFeesRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WithdrawalFeeDTO>>;
     public apiClientCreateWithdrawalFeePost(body?: CreateWithdrawalFeesRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<WithdrawalFeeDTO>('post',`${this.basePath}/api/Client/CreateWithdrawalFee`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Retrieves information of all active clients.
      * 
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetAllActiveClientsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ClientDTO>>;
     public apiClientGetAllActiveClientsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ClientDTO>>>;
     public apiClientGetAllActiveClientsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ClientDTO>>>;
     public apiClientGetAllActiveClientsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<Array<ClientDTO>>('get',`${this.basePath}/api/Client/GetAllActiveClients`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
  /**
     * Retrieves information of all clients for the client wallet dashboard
     * 
     * @param pageSize Page Size
     * @param pageNumber Page Number
     * @param startDate Start Date Filter
     * @param endDate End Date Filter
     * @param searchKeyword Keyword to search in the client&#x27;s name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
  public apiClientGetAllClientsGet(pageSize?: number, pageNumber?: number, startDate?: string, endDate?: string, searchKeyword?: string, observe?: 'body', reportProgress?: boolean): Observable<ClientWalletListDTO>;
  public apiClientGetAllClientsGet(pageSize?: number, pageNumber?: number, startDate?: string, endDate?: string, searchKeyword?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientWalletListDTO>>;
  public apiClientGetAllClientsGet(pageSize?: number, pageNumber?: number, startDate?: string, endDate?: string, searchKeyword?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientWalletListDTO>>;
  public apiClientGetAllClientsGet(pageSize?: number, pageNumber?: number, startDate?: string, endDate?: string, searchKeyword?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






      let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
      if (pageSize !== undefined && pageSize !== null) {
          queryParameters = queryParameters.set('pageSize', <any>pageSize);
      }
      if (pageNumber !== undefined && pageNumber !== null) {
          queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
      }
      if (startDate !== undefined && startDate !== null) {
          queryParameters = queryParameters.set('startDate', <any>startDate);
      }
      if (endDate !== undefined && endDate !== null) {
          queryParameters = queryParameters.set('endDate', <any>endDate);
      }
      if (searchKeyword !== undefined && searchKeyword !== null) {
          queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
      }

      let headers = this.defaultHeaders;

      // authentication (Bearer) required
      if (this.configuration.accessToken) {
          const accessToken = typeof this.configuration.accessToken === 'function'
              ? this.configuration.accessToken()
              : this.configuration.accessToken;
          headers = headers.set('Authorization', 'Bearer ' + accessToken);
      }
      // authentication (apiKey) required
      if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
          headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
      }

      // to determine the Accept header
      let httpHeaderAccepts: string[] = [
          'text/plain',
          'application/json',
          'text/json'
      ];
      const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
      if (httpHeaderAcceptSelected != undefined) {
          headers = headers.set('Accept', httpHeaderAcceptSelected);
      }

      // to determine the Content-Type header
      const consumes: string[] = [
      ];

      return this.httpClient.request<ClientWalletListDTO>('get',`${this.basePath}/api/Client/GetAllClients`,
          {
              params: queryParameters,
              withCredentials: this.configuration.withCredentials,
              headers: headers,
              observe: observe,
              reportProgress: reportProgress
          }
      );
  }
 
     /**
      * Retrieve the available banks.
      * 
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetBanksGet(observe?: 'body', reportProgress?: boolean): Observable<Array<BankDTO>>;
     public apiClientGetBanksGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BankDTO>>>;
     public apiClientGetBanksGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BankDTO>>>;
     public apiClientGetBanksGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<Array<BankDTO>>('get',`${this.basePath}/api/Client/GetBanks`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
    /**
     * Retrieve the cards of the client.
     * 
     * @param clientId Client&#x27;s id
     * @param pageSize Page Size
     * @param pageNumber Page Number
     * @param searchKeyword Keyword to search in bank&#x27;s name, nickname,
     * @param cardType Type of card
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetCardsByClientIdGet(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, cardType?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientCardListDTO>;
    public apiClientGetCardsByClientIdGet(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, cardType?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientCardListDTO>>;
    public apiClientGetCardsByClientIdGet(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, cardType?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientCardListDTO>>;
    public apiClientGetCardsByClientIdGet(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, cardType?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (cardType !== undefined && cardType !== null) {
            queryParameters = queryParameters.set('cardType', <any>cardType);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientCardListDTO>('get',`${this.basePath}/api/Client/GetCardsByClientId`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
 
     /**
      * Retrieves the information of a client
      * 
      * @param clientId Client&#x27;s id
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetClientByIdGet(clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientDTO>;
     public apiClientGetClientByIdGet(clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientDTO>>;
     public apiClientGetClientByIdGet(clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientDTO>>;
     public apiClientGetClientByIdGet(clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<ClientDTO>('get',`${this.basePath}/api/Client/GetClientById`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Retrieves information of clients and returns a list by pagination.
      * 
      * @param searchKeyword 
      * @param sort 
      * @param sortReverse 
      * @param page 
      * @param limit 
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetClientsByPageGet(searchKeyword?: string, sort?: string, sortReverse?: boolean, page?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ClientDTO>>;
     public apiClientGetClientsByPageGet(searchKeyword?: string, sort?: string, sortReverse?: boolean, page?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ClientDTO>>>;
     public apiClientGetClientsByPageGet(searchKeyword?: string, sort?: string, sortReverse?: boolean, page?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ClientDTO>>>;
     public apiClientGetClientsByPageGet(searchKeyword?: string, sort?: string, sortReverse?: boolean, page?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (searchKeyword !== undefined && searchKeyword !== null) {
             queryParameters = queryParameters.set('SearchKeyword', <any>searchKeyword);
         }
         if (sort !== undefined && sort !== null) {
             queryParameters = queryParameters.set('Sort', <any>sort);
         }
         if (sortReverse !== undefined && sortReverse !== null) {
             queryParameters = queryParameters.set('SortReverse', <any>sortReverse);
         }
         if (page !== undefined && page !== null) {
             queryParameters = queryParameters.set('Page', <any>page);
         }
         if (limit !== undefined && limit !== null) {
             queryParameters = queryParameters.set('Limit', <any>limit);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<Array<ClientDTO>>('get',`${this.basePath}/api/Client/GetClientsByPage`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
    /**
     * Retrieve the existing configuration of different fees of a client
     * 
     * @param clientId Client&#x27;s id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetFeesConfigurationGet(clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientConfigureFeesDTO>;
    public apiClientGetFeesConfigurationGet(clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientConfigureFeesDTO>>;
    public apiClientGetFeesConfigurationGet(clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientConfigureFeesDTO>>;
    public apiClientGetFeesConfigurationGet(clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientConfigureFeesDTO>('get',`${this.basePath}/api/Client/GetFeesConfiguration`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
 
     /**
      * Retrieve Pending withdrawals request of the client
      * 
      * @param clientId Optional Client&#x27;s id
      * @param page Optional Page number default is 1
      * @param limit Optional Page Size default is 10
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetPendingWithdrawalsGet(clientId?: number, page?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientWithdrawalsDTO>;
     public apiClientGetPendingWithdrawalsGet(clientId?: number, page?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientWithdrawalsDTO>>;
     public apiClientGetPendingWithdrawalsGet(clientId?: number, page?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientWithdrawalsDTO>>;
     public apiClientGetPendingWithdrawalsGet(clientId?: number, page?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
         if (page !== undefined && page !== null) {
             queryParameters = queryParameters.set('page', <any>page);
         }
         if (limit !== undefined && limit !== null) {
             queryParameters = queryParameters.set('limit', <any>limit);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<ClientWithdrawalsDTO>('get',`${this.basePath}/api/Client/GetPendingWithdrawals`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Retrieve the existing withdrawal fee of a client filtered further by vendor code and method of withdrawal
      * 
      * @param clientId Client&#x27;s id
      * @param vendorId Vendor&#x27;s id
      * @param method Withdrawal Type    1 - Bank;    2 - USDT;    3 - Cash Pickup
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetWithdrawalFeeGet(clientId?: number, vendorId?: number, method?: WithdrawalTypeEnum, observe?: 'body', reportProgress?: boolean): Observable<WithdrawalFeeDTO>;
     public apiClientGetWithdrawalFeeGet(clientId?: number, vendorId?: number, method?: WithdrawalTypeEnum, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WithdrawalFeeDTO>>;
     public apiClientGetWithdrawalFeeGet(clientId?: number, vendorId?: number, method?: WithdrawalTypeEnum, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WithdrawalFeeDTO>>;
     public apiClientGetWithdrawalFeeGet(clientId?: number, vendorId?: number, method?: WithdrawalTypeEnum, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
         if (vendorId !== undefined && vendorId !== null) {
             queryParameters = queryParameters.set('vendorId', <any>vendorId);
         }
         if (method !== undefined && method !== null) {
             queryParameters = queryParameters.set('method', <any>method);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<WithdrawalFeeDTO>('get',`${this.basePath}/api/Client/GetWithdrawalFee`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Retrieve the existing withdrawal fees of a client
      * 
      * @param clientId Client&#x27;s id
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetWithdrawalFeesByClientGet(clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<WithdrawalFeeDTO>>;
     public apiClientGetWithdrawalFeesByClientGet(clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<WithdrawalFeeDTO>>>;
     public apiClientGetWithdrawalFeesByClientGet(clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<WithdrawalFeeDTO>>>;
     public apiClientGetWithdrawalFeesByClientGet(clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<Array<WithdrawalFeeDTO>>('get',`${this.basePath}/api/Client/GetWithdrawalFeesByClient`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
   /**
     * Retrieve the withdrawals of the client
     * 
     * @param clientId Client&#x27;s id
     * @param pageSize Page size
     * @param pageNumber Page number
     * @param cardId Optional Card Id
     * @param startDate Start Date
     * @param endDate End Date
     * @param statuses Statuses, separated by comma [ 0 - All, 1 - Pending, 2 - Processing, 3 - Completed, 4 - Rejected]
     * @param searchKeyword Search keyword
     * @param apiVersion The requested API version
     * @param xVersion The requested API version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetWithdrawalsByClientGet(clientId?: number, pageSize?: number, pageNumber?: number, cardId?: number, startDate?: string, endDate?: string, statuses?: string, searchKeyword?: string, apiVersion?: string, xVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<RemittanceListDTO>;
    public apiClientGetWithdrawalsByClientGet(clientId?: number, pageSize?: number, pageNumber?: number, cardId?: number, startDate?: string, endDate?: string, statuses?: string, searchKeyword?: string, apiVersion?: string, xVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RemittanceListDTO>>;
    public apiClientGetWithdrawalsByClientGet(clientId?: number, pageSize?: number, pageNumber?: number, cardId?: number, startDate?: string, endDate?: string, statuses?: string, searchKeyword?: string, apiVersion?: string, xVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RemittanceListDTO>>;
    public apiClientGetWithdrawalsByClientGet(clientId?: number, pageSize?: number, pageNumber?: number, cardId?: number, startDate?: string, endDate?: string, statuses?: string, searchKeyword?: string, apiVersion?: string, xVersion?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (cardId !== undefined && cardId !== null) {
            queryParameters = queryParameters.set('cardId', <any>cardId);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (statuses !== undefined && statuses !== null) {
            queryParameters = queryParameters.set('statuses', <any>statuses);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }
        if (apiVersion !== undefined && apiVersion !== null) {
            queryParameters = queryParameters.set('api-version', <any>apiVersion);
        }

        let headers = this.defaultHeaders;
        if (xVersion !== undefined && xVersion !== null) {
            headers = headers.set('X-Version', String(xVersion));
        }

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain; X-Version=1.0',
            'application/json; X-Version=1.0',
            'text/json; X-Version=1.0'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<RemittanceListDTO>('get',`${this.basePath}/api/Client/GetWithdrawalsByClient`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

 
     /**
      * Retrieve all withdrawal history of the client
      * 
      * @param clientId Optional Client&#x27;s id
      * @param page Optional Page number default is 1
      * @param limit Optional PageSize default is 10
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientGetWithdrawalsHistoryGet(clientId?: number, page?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientWithdrawalsHistoryDTO>;
     public apiClientGetWithdrawalsHistoryGet(clientId?: number, page?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientWithdrawalsHistoryDTO>>;
     public apiClientGetWithdrawalsHistoryGet(clientId?: number, page?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientWithdrawalsHistoryDTO>>;
     public apiClientGetWithdrawalsHistoryGet(clientId?: number, page?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
         if (page !== undefined && page !== null) {
             queryParameters = queryParameters.set('page', <any>page);
         }
         if (limit !== undefined && limit !== null) {
             queryParameters = queryParameters.set('limit', <any>limit);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<ClientWithdrawalsHistoryDTO>('get',`${this.basePath}/api/Client/GetWithdrawalsHistory`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * The client requests for a withdrawal remittance.
      * 
      * @param body The request body containts the following:
  1. IdMerchantSource - source of funds
  2. IdCardDestination - destination of remittance
  3. VendorId - Vendor&#x27;s id where remittance will happen
  4. ClientId - Client&#x27;s Id
  5. RequesterUserId - The id of the user of the client who requested the remittance
  6. RequesterName - Name of requester
  7. Method ( 1 - BANK, 2 - USDT, 3 - CASH PICKUP ) - method to be used for remittance
  8. FeeOnTop - Withdrawal Fee On Top
  9. FeeAtCost - Withdrawal Fee At Cost
  10. WithdrawalFee - Total Withdrawal Fee
  11. Amount - Amount request to be remitted
  12. NetAmount - Amount to be remitted less the withdrawal fee
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientRequestWithdrawalPost(body?: CreateCardWithdrawalRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<CardTransactionDTO>;
     public apiClientRequestWithdrawalPost(body?: CreateCardWithdrawalRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CardTransactionDTO>>;
     public apiClientRequestWithdrawalPost(body?: CreateCardWithdrawalRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CardTransactionDTO>>;
     public apiClientRequestWithdrawalPost(body?: CreateCardWithdrawalRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<CardTransactionDTO>('post',`${this.basePath}/api/Client/RequestWithdrawal`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Update the card information
      * 
      * @param body The request body contains the following:
 1. Id - Card id
 2. ClientId 
 3. CardType (1 - Bank, 2 - USDT, 3 - EWallet )
 4. BankName
 5. AccountNumber
 6. NickName
 7. BinanceId
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientUpdateCardPut(body?: UpdateCardRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<CardDTO>;
     public apiClientUpdateCardPut(body?: UpdateCardRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CardDTO>>;
     public apiClientUpdateCardPut(body?: UpdateCardRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CardDTO>>;
     public apiClientUpdateCardPut(body?: UpdateCardRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<CardDTO>('put',`${this.basePath}/api/Client/UpdateCard`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Updates the information of a client
      * 
      * @param body The request body contains the following:
 1. Id
 2. Name
 3. ProviderId
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientUpdateClientPost(body?: UpdateClientRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<ClientDTO>;
     public apiClientUpdateClientPost(body?: UpdateClientRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientDTO>>;
     public apiClientUpdateClientPost(body?: UpdateClientRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientDTO>>;
     public apiClientUpdateClientPost(body?: UpdateClientRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<ClientDTO>('post',`${this.basePath}/api/Client/UpdateClient`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Change the status of client
      * 
      * @param clientId Client&#x27;s Id
      * @param statusEnum 1 - Active   2 - Inactive   3 - Deleted
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientUpdateClientStatusPost(clientId?: number, statusEnum?: StatusEnum, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
     public apiClientUpdateClientStatusPost(clientId?: number, statusEnum?: StatusEnum, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
     public apiClientUpdateClientStatusPost(clientId?: number, statusEnum?: StatusEnum, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
     public apiClientUpdateClientStatusPost(clientId?: number, statusEnum?: StatusEnum, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (clientId !== undefined && clientId !== null) {
             queryParameters = queryParameters.set('clientId', <any>clientId);
         }
         if (statusEnum !== undefined && statusEnum !== null) {
             queryParameters = queryParameters.set('statusEnum', <any>statusEnum);
         }
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<boolean>('post',`${this.basePath}/api/Client/UpdateClientStatus`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Update the configuration of different fees for a client
      * 
      * @param clientId Client&#x27;s id
      * @param body Put request containing the updated fees configuration
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientUpdateFeesConfigurationClientIdPut(clientId: number, body?: ClientConfigureFeesDTO, observe?: 'body', reportProgress?: boolean): Observable<ClientConfigureFeesDTO>;
     public apiClientUpdateFeesConfigurationClientIdPut(clientId: number, body?: ClientConfigureFeesDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientConfigureFeesDTO>>;
     public apiClientUpdateFeesConfigurationClientIdPut(clientId: number, body?: ClientConfigureFeesDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientConfigureFeesDTO>>;
     public apiClientUpdateFeesConfigurationClientIdPut(clientId: number, body?: ClientConfigureFeesDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (clientId === null || clientId === undefined) {
             throw new Error('Required parameter clientId was null or undefined when calling apiClientUpdateFeesConfigurationClientIdPut.');
         }
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<ClientConfigureFeesDTO>('put',`${this.basePath}/api/Client/UpdateFeesConfiguration/${encodeURIComponent(String(clientId))}`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Update the withdrawal fee
      * 
      * @param body The request body contains the following:
 1. Id - Withdrawal fee id
 2. VendorId - Vendor&#x27;s id
 3. ClientId - Client&#x27;s id
 4. Method - Remittance Method  ( 1 -  thru BANK,    2 - thru Binance, 3 - thru cash pickup )
 5. FeeOnTopPercent - Fee On Top in percentage
 6. FeeOnTopFixed  - Fee On Top in fixed amount
 7. FeeAtCostPercent - Fee At Cost in percentage
 8. FeeAtCostFixed - Fee At Cost in fixed amount
 9. Status - status of the withdrawal fee (  1 - Active, 2 - Inactive, 3 - Deleted )
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public apiClientUpdateWithdrawalFeePost(body?: UpdateWithdrawalFeesRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<WithdrawalFeeDTO>;
     public apiClientUpdateWithdrawalFeePost(body?: UpdateWithdrawalFeesRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WithdrawalFeeDTO>>;
     public apiClientUpdateWithdrawalFeePost(body?: UpdateWithdrawalFeesRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WithdrawalFeeDTO>>;
     public apiClientUpdateWithdrawalFeePost(body?: UpdateWithdrawalFeesRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
 
         let headers = this.defaultHeaders;
 
         // authentication (Bearer) required
         if (this.configuration.accessToken) {
             const accessToken = typeof this.configuration.accessToken === 'function'
                 ? this.configuration.accessToken()
                 : this.configuration.accessToken;
             headers = headers.set('Authorization', 'Bearer ' + accessToken);
         }
         // authentication (apiKey) required
         if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
             headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
         }
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'text/plain',
             'application/json',
             'text/json'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
             'application/json',
             'text/json',
             'application/_*+json'
         ];
         const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
         if (httpContentTypeSelected != undefined) {
             headers = headers.set('Content-Type', httpContentTypeSelected);
         }
 
         return this.httpClient.request<WithdrawalFeeDTO>('post',`${this.basePath}/api/Client/UpdateWithdrawalFee`,
             {
                 body: body,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }

       /**
     * Retrieves information of all clients aggregates
     * 
     * @param clientId optional client id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetClientAggregatesGet(clientId?: number, observe?: 'body', reportProgress?: boolean): Observable<ClientAggregatesDTO>;
    public apiClientGetClientAggregatesGet(clientId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientAggregatesDTO>>;
    public apiClientGetClientAggregatesGet(clientId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientAggregatesDTO>>;
    public apiClientGetClientAggregatesGet(clientId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientAggregatesDTO>('get',`${this.basePath}/api/Client/GetClientAggregates`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the chart data for income statement
     * 
     * @param body request data
     * @param pageSize Page Size
     * @param pageNumber Page Number
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientDashboardGetIncomeStatementChartPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'body', reportProgress?: boolean): Observable<IncomeStatementChart>;
    public apiClientDashboardGetIncomeStatementChartPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IncomeStatementChart>>;
    public apiClientDashboardGetIncomeStatementChartPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IncomeStatementChart>>;
    public apiClientDashboardGetIncomeStatementChartPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<IncomeStatementChart>('post',`${this.basePath}/api/Client/Dashboard/GetIncomeStatementChart`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
 
    /**
     * Retrieves balances for each of the channels of the client
     * 
     * @param clientId client id
     * @param pageSize PageSize
     * @param pageNumber Page Number
     * @param searchKeyword Search Keyword - search on client&#x27;s name, channel&#x27;s name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBalanceForEachChannel(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, observe?: 'body', reportProgress?: boolean): Observable<ClientBalanceResultDTO>;
    public getBalanceForEachChannel(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ClientBalanceResultDTO>>;
    public getBalanceForEachChannel(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClientBalanceResultDTO>>;
    public getBalanceForEachChannel(clientId?: number, pageSize?: number, pageNumber?: number, searchKeyword?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (searchKeyword !== undefined && searchKeyword !== null) {
            queryParameters = queryParameters.set('searchKeyword', <any>searchKeyword);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ClientBalanceResultDTO>('get',`${this.basePath}/api/Client/GetBalanceForEachChannel`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
    
    /**
     * Retrieves the success rates of the clients.
     * 
     * @param clientId Client&#x27;s id
     * @param startDate Start Date of CI and CO Transactions
     * @param endDate End Date of CI and CO Transactions
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetSuccessRateGet(clientId?: number, startDate?: Date, endDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<Array<SuccessRateSummary>>;
    public apiClientGetSuccessRateGet(clientId?: number, startDate?: Date, endDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SuccessRateSummary>>>;
    public apiClientGetSuccessRateGet(clientId?: number, startDate?: Date, endDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SuccessRateSummary>>>;
    public apiClientGetSuccessRateGet(clientId?: number, startDate?: Date, endDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<SuccessRateSummary>>('get',`${this.basePath}/api/Client/GetSuccessRate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

        /**
     * Retrieve the account number of a card of the client. For authorized users only.
     * 
     * @param cardId Card&#x27;s id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
        public apiClientGetAccountNumberGet(cardId?: number, observe?: 'body', reportProgress?: boolean): Observable<string>;
        public apiClientGetAccountNumberGet(cardId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
        public apiClientGetAccountNumberGet(cardId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
        public apiClientGetAccountNumberGet(cardId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
    
    
            let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
            if (cardId !== undefined && cardId !== null) {
                queryParameters = queryParameters.set('cardId', <any>cardId);
            }
    
            let headers = this.defaultHeaders;
    
            // authentication (Bearer) required
            if (this.configuration.accessToken) {
                const accessToken = typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken()
                    : this.configuration.accessToken;
                headers = headers.set('Authorization', 'Bearer ' + accessToken);
            }
            // authentication (apiKey) required
            if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
                headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
            }
    
            // to determine the Accept header
            let httpHeaderAccepts: string[] = [
                'text/plain',
                'application/json',
                'text/json'
            ];
            const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            if (httpHeaderAcceptSelected != undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
    
            // to determine the Content-Type header
            const consumes: string[] = [
            ];
    
            return this.httpClient.request<string>('get',`${this.basePath}/api/Client/GetAccountNumber`,
                {
                    params: queryParameters,
                    withCredentials: this.configuration.withCredentials,
                    headers: headers,
                    observe: observe,
                    reportProgress: reportProgress
                }
            );
        }

           /**
     * Retrieves the uploaded receipts of a withdrawal request.
     * 
     * @param transactionNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetWithdrawalsReceiptsURLsGet(transactionNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public apiClientGetWithdrawalsReceiptsURLsGet(transactionNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public apiClientGetWithdrawalsReceiptsURLsGet(transactionNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public apiClientGetWithdrawalsReceiptsURLsGet(transactionNumber?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (transactionNumber !== undefined && transactionNumber !== null) {
            queryParameters = queryParameters.set('transactionNumber', <any>transactionNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/api/Client/GetWithdrawals/Receipts/URLs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves information of all co fund balances of all clients
     * 
     * @param pageSize Page Size
     * @param pageNumber Page Number
     * @param apiVersion The requested API version
     * @param xVersion The requested API version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientGetAllClientsCOFundsGet(pageSize?: number, pageNumber?: number, apiVersion?: string, xVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ClientCOFundsBalanceDTO>>;
    public apiClientGetAllClientsCOFundsGet(pageSize?: number, pageNumber?: number, apiVersion?: string, xVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ClientCOFundsBalanceDTO>>>;
    public apiClientGetAllClientsCOFundsGet(pageSize?: number, pageNumber?: number, apiVersion?: string, xVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ClientCOFundsBalanceDTO>>>;
    public apiClientGetAllClientsCOFundsGet(pageSize?: number, pageNumber?: number, apiVersion?: string, xVersion?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (apiVersion !== undefined && apiVersion !== null) {
            queryParameters = queryParameters.set('api-version', <any>apiVersion);
        }

        let headers = this.defaultHeaders;
        if (xVersion !== undefined && xVersion !== null) {
            headers = headers.set('X-Version', String(xVersion));
        }

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain; X-Version=1.0',
            'application/json; X-Version=1.0',
            'text/json; X-Version=1.0'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ClientCOFundsBalanceDTO>>('get',`${this.basePath}/api/Client/GetAllClients/COFunds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the chart data for income statement per month
     * 
     * @param body request data
     * @param pageSize Page Size
     * @param pageNumber Page Number
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientDashboardGetIncomeStatementChartMonthlyPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'body', reportProgress?: boolean): Observable<IncomeStatementChart>;
    public apiClientDashboardGetIncomeStatementChartMonthlyPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IncomeStatementChart>>;
    public apiClientDashboardGetIncomeStatementChartMonthlyPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IncomeStatementChart>>;
    public apiClientDashboardGetIncomeStatementChartMonthlyPost(body?: IncomeStatementChartDataRequestDTO, pageSize?: number, pageNumber?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<IncomeStatementChart>('post',`${this.basePath}/api/Client/Dashboard/GetIncomeStatementChartMonthly`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the pie chart data for daily transaction
     * 
     * @param body request data
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientDashboardGetDailyTransactionPieChartPost(body?: DailyTransactionPieChartDataRequestDTO, observe?: 'body', reportProgress?: boolean): Observable<DailyTransactionPieChart>;
    public apiClientDashboardGetDailyTransactionPieChartPost(body?: DailyTransactionPieChartDataRequestDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DailyTransactionPieChart>>;
    public apiClientDashboardGetDailyTransactionPieChartPost(body?: DailyTransactionPieChartDataRequestDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DailyTransactionPieChart>>;
    public apiClientDashboardGetDailyTransactionPieChartPost(body?: DailyTransactionPieChartDataRequestDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<DailyTransactionPieChart>('post',`${this.basePath}/api/Client/Dashboard/GetDailyTransactionPieChart`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the payment channels summary
     * 
     * @param clientId Client&#x27;s id
     * @param startDate Start Date (yyyy-MM-dd)
     * @param endDate End Date (yyyy-MM-dd)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientDashboardPaymentChannelsSummaryGet(clientId?: number, startDate?: string, endDate?: string, observe?: 'body', reportProgress?: boolean): Observable<PaymentChannelSummary>;
    public apiClientDashboardPaymentChannelsSummaryGet(clientId?: number, startDate?: string, endDate?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PaymentChannelSummary>>;
    public apiClientDashboardPaymentChannelsSummaryGet(clientId?: number, startDate?: string, endDate?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaymentChannelSummary>>;
    public apiClientDashboardPaymentChannelsSummaryGet(clientId?: number, startDate?: string, endDate?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PaymentChannelSummary>('get',`${this.basePath}/api/Client/Dashboard/PaymentChannelsSummary`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * The client requests for a withdrawal remittance via cash pick-up.
     * 
     * @param idCardDestination 
     * @param clientId 
     * @param requesterUserId 
     * @param requesterName 
     * @param method 
     * @param feeOnTopPercent 
     * @param feeOnTopFixed 
     * @param feeAtCostPercent 
     * @param feeAtCostFixed 
     * @param amount 
     * @param netAmount 
     * @param idNumber 
     * @param fullNameIdHolder 
     * @param iDType 
     * @param remarks 
     * @param validIdFiles 
     * @param letterFiles 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiClientRequestWithdrawalByCashPickupPostForm(idCardDestination?: number, clientId?: number, requesterUserId?: number, requesterName?: string, method?: WithdrawalTypeEnum, feeOnTopPercent?: number, feeOnTopFixed?: number, feeAtCostPercent?: number, feeAtCostFixed?: number, amount?: number, netAmount?: number, idNumber?: string, fullNameIdHolder?: string, iDType?: ValidIDEnum, remarks?: string, validIdFiles?: Array<Blob>, letterFiles?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<CardTransactionDTO>;
    public apiClientRequestWithdrawalByCashPickupPostForm(idCardDestination?: number, clientId?: number, requesterUserId?: number, requesterName?: string, method?: WithdrawalTypeEnum, feeOnTopPercent?: number, feeOnTopFixed?: number, feeAtCostPercent?: number, feeAtCostFixed?: number, amount?: number, netAmount?: number, idNumber?: string, fullNameIdHolder?: string, iDType?: ValidIDEnum, remarks?: string, validIdFiles?: Array<Blob>, letterFiles?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CardTransactionDTO>>;
    public apiClientRequestWithdrawalByCashPickupPostForm(idCardDestination?: number, clientId?: number, requesterUserId?: number, requesterName?: string, method?: WithdrawalTypeEnum, feeOnTopPercent?: number, feeOnTopFixed?: number, feeAtCostPercent?: number, feeAtCostFixed?: number, amount?: number, netAmount?: number, idNumber?: string, fullNameIdHolder?: string, iDType?: ValidIDEnum, remarks?: string, validIdFiles?: Array<Blob>, letterFiles?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CardTransactionDTO>>;
    public apiClientRequestWithdrawalByCashPickupPostForm(idCardDestination?: number, clientId?: number, requesterUserId?: number, requesterName?: string, method?: WithdrawalTypeEnum, feeOnTopPercent?: number, feeOnTopFixed?: number, feeAtCostPercent?: number, feeAtCostFixed?: number, amount?: number, netAmount?: number, idNumber?: string, fullNameIdHolder?: string, iDType?: ValidIDEnum, remarks?: string, validIdFiles?: Array<Blob>, letterFiles?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


















        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (apiKey) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-API-KEY"]) {
            headers = headers.set('X-API-KEY', this.configuration.apiKeys["X-API-KEY"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (idCardDestination !== undefined) {
            formParams = formParams.append('IdCardDestination', <any>idCardDestination) as any || formParams;
        }
        if (clientId !== undefined) {
            formParams = formParams.append('ClientId', <any>clientId) as any || formParams;
        }
        if (requesterUserId !== undefined) {
            formParams = formParams.append('RequesterUserId', <any>requesterUserId) as any || formParams;
        }
        if (requesterName !== undefined) {
            formParams = formParams.append('RequesterName', <any>requesterName) as any || formParams;
        }
        if (method !== undefined) {
            formParams = formParams.append('Method', <any>method) as any || formParams;
        }
        if (feeOnTopPercent !== undefined) {
            formParams = formParams.append('FeeOnTopPercent', <any>feeOnTopPercent) as any || formParams;
        }
        if (feeOnTopFixed !== undefined) {
            formParams = formParams.append('FeeOnTopFixed', <any>feeOnTopFixed) as any || formParams;
        }
        if (feeAtCostPercent !== undefined) {
            formParams = formParams.append('FeeAtCostPercent', <any>feeAtCostPercent) as any || formParams;
        }
        if (feeAtCostFixed !== undefined) {
            formParams = formParams.append('FeeAtCostFixed', <any>feeAtCostFixed) as any || formParams;
        }
        if (amount !== undefined) {
            formParams = formParams.append('Amount', <any>amount) as any || formParams;
        }
        if (netAmount !== undefined) {
            formParams = formParams.append('NetAmount', <any>netAmount) as any || formParams;
        }
        if (idNumber !== undefined) {
            formParams = formParams.append('IdNumber', <any>idNumber) as any || formParams;
        }
        if (fullNameIdHolder !== undefined) {
            formParams = formParams.append('FullNameIdHolder', <any>fullNameIdHolder) as any || formParams;
        }
        if (iDType !== undefined) {
            formParams = formParams.append('IDType', <any>iDType) as any || formParams;
        }
        if (remarks !== undefined) {
            formParams = formParams.append('Remarks', <any>remarks) as any || formParams;
        }
        if (validIdFiles) {
            validIdFiles.forEach((element) => {
                formParams = formParams.append('validIdFiles', <any>element) as any || formParams;
            })
        }
        if (letterFiles) {
            letterFiles.forEach((element) => {
                formParams = formParams.append('letterFiles', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<CardTransactionDTO>('post',`${this.basePath}/api/Client/RequestWithdrawalByCashPickup`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


 }
 